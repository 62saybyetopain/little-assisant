

1. [P1] 修復 XSS 漏洞引發的語法崩潰 (Syntax Crash)

偵測位置： customer-list.html (約第 336 行) 與 customer-profile.html (約第 343 行) 問題類別： [P1] 修復 XSS 漏洞 的副作用

問題分析： 在 generateCardHtml (列表頁) 與 renderRecords (個人頁) 中，我們為了修復 XSS 而使用了 window.escapeHtml。 escapeHtml 會將單引號 ' 轉換為 &#039;。 當這些變數被放入 onclick 屬性時：

    程式碼：onclick="handleDeleteCustomer(event, '${safeId}', '${safeName}')"

    情境：假設名字是 O'Neil，轉義後為 O&#039;Neil。

    瀏覽器渲染：HTML 屬性值為 handleDeleteCustomer(..., 'O&#039;Neil')。

    崩潰點：當使用者點擊時，瀏覽器會先將 HTML Entity 解碼，JavaScript 引擎實際執行的是 handleDeleteCustomer(..., 'O'Neil')。這會導致 Uncaught SyntaxError: missing ) after argument list，按鈕完全失效。

修復方案： 利用 data-* 屬性存放已轉義的字串，並在 onclick 中使用 this.dataset 取值。dataset 會自動處理編碼問題，且不會破壞 JS 語法結構。

替換程式碼 (針對 customer-list.html 第 336 行周圍)：
JavaScript

        // [Fix] 改用 dataset 傳遞參數，防止因名字含單引號導致 onclick 語法錯誤 (Syntax Crash)
        // 注意：onclick="viewRecord(this.dataset.id)"
        return `
            <div class="customer-card" data-id="${safeId}" onclick="window.location.href='customer-profile.html?id=' + this.dataset.id">
              <button class="delete-card-btn" 
                data-id="${safeId}" 
                data-name="${safeName}"
                onclick="handleDeleteCustomer(event, this.dataset.id, this.dataset.name)" 
                title="移至回收桶">🗑️</button>
              
              <div class="customer-header">


2. [P0] 解決初始化順序問題 (Service Record Page Crash)

偵測位置： service-record.html (約第 460-475 行) 問題類別： [P0] 解決初始化順序問題

問題分析： customer-profile.html 與 customer-list.html 都正確實作了 app-ready 事件監聽機制。 但是，service-record.html 的初始化邏輯直接寫在 DOMContentLoaded 內，且若 window.AppCustomerManager 不存在就直接 return (終止執行)。

    崩潰情境：app.js 的初始化通常是非同步的（或比 DOM 解析慢）。當使用者直接重新整理 service-record.html 時，DOM 載入完成時 AppCustomerManager 極可能尚未就緒，導致頁面顯示錯誤訊息或白屏，無法載入顧客資料。

修復方案： 將初始化邏輯封裝為 bootPage 函式，並加入對 app-ready 事件的監聽。

替換程式碼 (針對 service-record.html 的 Script 區塊開頭)：
JavaScript

    /**
     * 服務紀錄頁面初始化
     */
    document.addEventListener('DOMContentLoaded', () => {
      console.log('✅ 服務紀錄頁面載入 - 等待核心就緒...');

      // [Fix] 封裝初始化邏輯，確保依賴就緒後才執行 (對應 [P0] 初始化順序問題)
      const bootPage = async () => {
        try {
          const urlParams = new URLSearchParams(window.location.search);
          const customerId = urlParams.get('customerId');

          if (!customerId) {
            showAlert('無效的客戶 ID', 'error');
            setTimeout(() => { window.location.href = 'customer-list.html'; }, 2000);
            return;
          }

          if (!window.AppCustomerManager) {
             throw new Error('Manager dependencies missing');
          }
          
          // ... (原有的初始化邏輯：取得 customer, 設定 title, 初始化 UIAssessment, ServiceRecordFlow) ...
          // 注意：請將原本 DOMContentLoaded 內的邏輯搬移至此
          
          // (略...為節省篇幅，請保留原有的邏輯內容，僅修改外層結構)
          
          const customer = window.AppCustomerManager.getCustomerById(customerId);
          // ...
          
          console.log('🔄 初始化 ServiceRecordFlow...');
          await window.AppServiceRecordFlow.init(customerId);
          
          console.log('✅ 頁面初始化完成');

          // ... (事件監聽) ...

        } catch (error) {
          console.error('❌ 頁面初始化錯誤：', error);
          showAlert(`初始化錯誤：${error.message}`, 'error');
        }
      };

      // [Fix] 檢查 app 狀態，若未就緒則監聽事件
      if (window.isAppReady) {
        bootPage();
      } else {
        document.addEventListener('app-ready', bootPage);
      }
    });

2. 不屬於十大類別但可能導致系統崩潰的問題


3. [P1] 修復殘留髒資料問題 (Sync Manager Logic)

偵測位置： sync-manager.js (constructor 區塊) 問題類別： [P1] 修復殘留髒資料問題

問題分析： 正如您在上一輪對話中指出的，雖然我們修復了 this.storageKey 未定義的問題，但系統在生成新 ID 後，遺漏了清理舊的 "undefined" 鍵值。這會導致用戶的 localStorage 中永遠存有一筆無法被使用的髒資料。

修復方案： 在 constructor 初始化 Key 之後，立即檢查並移除舊的 "undefined" 資料。

替換程式碼 (針對 sync-manager.js 的 constructor)：
JavaScript

  constructor() {
    this.peer = null;       // 本機 Peer 物件
    this.conn = null;       // 與對方的連線物件
    this.myId = null;       // 本機 ID
    this.isConnected = false;
    
    // 定義 storageKey，避免 init() 存取 localStorage 時使用 "undefined" 字串
    // 確保 ID 能正確持久化儲存
    this.storageKey = 'p2p_device_id'; 
    
    // [Fix] 清理舊版 Bug 產生的垃圾資料 (對應 [P1] 修復殘留髒資料問題)
    // 檢查是否存在因變數未定義而產生的 "undefined" 鍵值，若有則移除
    if (typeof localStorage !== 'undefined' && localStorage.getItem('undefined')) {
        localStorage.removeItem('undefined');
        console.info('🧹 [SyncManager] 已自動清理舊版殘留的髒資料 (undefined key)');
    }
    
    // 定義訊息類型
    this.MSG_TYPES = {
      HANDSHAKE: 'HANDSHAKE', // 握手確認
      FULL_SYNC: 'FULL_SYNC', // 全量同步 (匯入備份)
      UPDATE: 'UPDATE'        // 單筆更新
    };
  }

1. [P1] 觸診標籤點擊崩潰 (JS Syntax Crash)

偵測位置： service-record-flow.js (約第 297-313 行，renderPalpationChips 函式) 問題類別： [P1] 修復 XSS 漏洞的副作用 (同類問題的新發現)

問題分析： 雖然您已經修復了列表頁面的 XSS，但在 service-record-flow.js 的 renderPalpationChips 中，使用了相同的脆弱寫法。

    程式碼：
    JavaScript

    onclick="window.appServiceRecordFlow.openPalpationModal('${safeTagId}', '${safeTagName}')"

    崩潰情境： 如果肌群名稱包含單引號（例如 Runner's Knee 或自訂名稱 User's Muscle），escapeHtml 會將其轉義為 User&#039;s Muscle。 當 HTML 屬性被瀏覽器解析後，JS 引擎接收到的參數字串為 'User's Muscle'。這會導致 單引號提早閉合，拋出 Uncaught SyntaxError，導致該標籤點擊無反應，無法開啟觸診視窗。

修復方案： 移除 inline onclick 中的變數傳遞，改用 data-* 屬性儲存資料，並透過 this.dataset 安全取值。

替換程式碼 (針對 service-record-flow.js 的 renderPalpationChips 函式內部)：
JavaScript

        return `
            <div class="palpation-chip" 
                 data-id="${safeTagId}"
                 data-name="${safeTagName}"
                 onclick="window.appServiceRecordFlow.openPalpationModal(this.dataset.id, this.dataset.name)"
                 style="background: white; border: 1px solid #cbd5e1; border-radius: 16px; padding: 6px 12px; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: all 0.2s;">
                <span style="width: 8px; height: 8px; background: #3b82f6; border-radius: 50%; display: inline-block;"></span>
                ${safeTagName}
            </div>
        `;

2. [P1] 舊版備份匯入失敗 (Logic Gap)

偵測位置： settings.js (約第 900 行，handleFileImport 函式) 問題類別： [P0] 補完缺失函式/邏輯

問題分析： 在 settings.js 中，單一顧客匯入 (handleCustomerJSONImport) 正確呼叫了 normalizeImportData 來標準化資料格式。但是，完整備份匯入 (handleFileImport) 卻直接將原始 JSON 傳給 analyzeImport。

    崩潰情境： 使用者嘗試匯入 v1.0 或 v2.0 的舊版備份檔案 (格式為 { customers: [...] })。

    analyzeImport 預期接收 { customerDetails: {...} } 結構。 由於缺少 normalizeImportData 轉換步驟，analyzeImport 會找不到任何資料，導致分析結果為空，使用者看到「無資料可匯入」，無法還原舊版備份。

修復方案： 在呼叫 analyzeImport 之前，必須先呼叫 normalizeImportData 進行格式標準化。

替換程式碼 (針對 settings.js 的 handleFileImport 函式)：
JavaScript

  handleFileImport(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const json = JSON.parse(ev.target.result);
        // [Fix] 匯入前先進行資料標準化，確保舊版備份 (Array) 能被正確識別
        if (window.AppDataExportService && window.AppDataExportService.analyzeImport) {
            const normalizedData = window.AppDataExportService.normalizeImportData(json);
            const analysis = window.AppDataExportService.analyzeImport(normalizedData);
            this.showImportDecisionModal(analysis, normalizedData); 
        } else {
            // ... (舊版 fallback)
        }
      } catch (err) {
        alert('檔案解析失敗: ' + err.message);
      }
      e.target.value = '';
    };
    reader.readAsText(file);
  },

3. [P2] 顧客列表排序不穩定 (NaN Date Issue)

偵測位置： customer-manager.js (約第 58-60 行，getAllCustomers 函式) 問題類別： [P1] 修復殘留髒資料問題 (延伸)

問題分析： 排序邏輯使用了 new Date(a.updatedAt).getTime()。

    風險情境：如果 updatedAt 欄位遺失 (舊資料) 或格式錯誤，new Date(...) 會回傳 Invalid Date，其 .getTime() 為 NaN (Not a Number)。

    後果：dateB - dateA 若包含 NaN，排序結果將變得不可預測 (瀏覽器實作不一，通常是不排序)。這會導致顧客列表的順序在某些舊資料存在時變得混亂，無法正確將最新顧客排在最前。

修復方案： 加入 || 0 的防呆機制，確保 undefined 或無效日期會被視為 0 (最舊時間)，保證排序穩定性。

替換程式碼 (針對 customer-manager.js 的 getAllCustomers 函式)：
JavaScript

  getAllCustomers() {
    try {
      const index = this.storage.loadCustomerIndex() || [];
      // [Fix] 加入日期防呆，避免 undefined 導致 NaN 破壞排序
      return index.sort((a, b) => {
        const dateA = a.updatedAt ? new Date(a.updatedAt).getTime() : 0;
        const dateB = b.updatedAt ? new Date(b.updatedAt).getTime() : 0;
        return dateB - dateA;
      });
    } catch (error) {
      console.error('Get customer index error:', error);
      return [];
    }
  }

額外發現的關鍵問題分析
1. [P0] 設定頁面初始化崩潰 (Settings Page Crash)

    偵測依據： 您的截圖中，紅色錯誤明確指出 TypeError: can't access property "getTagsByCategory", window.AppTagManager is undefined 發生在 settings.js:554。

    問題分析： 您提供的「Fix 2」只修復了 service-record.html 的初始化順序，但完全忽略了截圖中真正報錯的 settings.js。當使用者在設定頁面重新整理時，AppTagManager 還沒載入，但 settings.js 已經嘗試執行 loadMuscleList，導致整個設定頁面腳本中斷。

    後果： 設定頁面功能全毀，標籤無法載入。

2. [P1] 事件冒泡導致的「殭屍跳轉」 (Event Bubbling)

    偵測依據： 您提供的「Fix 1」程式碼片段。

    問題分析： 您的 HTML 結構是 <div onclick="跳轉頁面"> <button onclick="刪除">。

        當使用者點擊「刪除按鈕」時，瀏覽器會執行刪除邏輯。

        但是，點擊事件會「向上冒泡 (Bubble Up)」傳遞給父層的 div。

        結果：使用者點了刪除，系統彈出刪除確認，但背景同時開始載入該客戶的個人頁面。這會導致資料狀態錯亂（在跳轉前被刪除）或使用者體驗極差。

    後果： 刪除操作觸發頁面跳轉，可能導致刪除失敗或 Console 報錯。

3. [P1] HTML 屬性雙引號破壞 (Attribute Break)

    偵測依據： 您提供的「Fix 1」與「Fix 4」使用 data-name="${safeName}"。

    問題分析： 您的 escapeHtml 函式通常只轉義單引號 '。如果客戶名稱中包含 雙引號 " (例如暱稱 The "Rock" )，HTML 解析器會看到 data-name="The "，後面的 Rock" 會被視為無效屬性或語法錯誤，再次導致版面錯亂或 JS 取值失敗。

 修復清單為 10 大項，完整方案：


    [P0] 補完缺失函式 (createUnifiedImportInput, showRecycleBinModal)。(新)

    [P0] 修復 HTML/JS 綁定錯誤 (fixIndices vs cleanOrphans)。(新)

    [P0] 解決初始化順序問題 (確保 escapeHtml, ServiceRecordFlow 就緒後才執行邏輯)。(新)

    [P0] 修正 vacuum 呼叫名稱錯誤。

    [P0] 補上 UI 事件缺少的 clickedPart 參數 (修復模板自動觸發)。

    [P0] 修正模板套用後的資料同步問題 (修復換頁即焚)。

    [P0] 修正編輯模式下的 UI 資料回填 (修復人體圖白屏)。

    [P1] 修復評估動作名稱「未知」問題 (快取邏輯)。

    [P1] 修復 XSS 漏洞。

    [P1] 修復殘留髒資料問題。

清除之前的 context，請檢查這份檔案，除了上述的問題以外，是否存在其他錯誤。

務必具體指出需要更換或添加的段落，並提供替換該段落的程式碼

注意，修改方案應該基於這次上傳的附件檔案，請嚴格遵守這項指令。


修復時如有假設情境務必說明(可能影響修正方向)，請總是說明為甚麼修正方案可以正確修復偵測到的問題